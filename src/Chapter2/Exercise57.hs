module Chapter2.Exercise57 (parseExpr) where

import Control.Applicative ((<|>))

import Text.Parsec.Char (spaces)
import Text.Parsec.Combinator (eof)
import Text.Parsec.Prim (runParser)
import Text.Parsec.String (Parser)

import Chapter2.Symbolic
    (
        Expr(..),
        add,
        antiexpr,
        constant,
        divide,
        multiply,
        parens,
        power,
        sub,
        variable
    )

-- | Suppose we want to modify the differentiation program so it works with
-- ordinary mathematical notation, in which `+` and `*` are infix rather than
-- prefix operators. Since the differentation program is defined in terms of
-- abstract data, we cna modify it to work with different representations of
-- expressions solely by chaning the predicates, selectors and constructors that
-- define the representation of algebraic expressions on which the differentator
-- is to operate.
--
-- a. Show how to do this in order to differentiate algebraic expressions
-- presented in infix form, such as
-- @
--     (x + (3 * (x + (y + 2))))
-- @
-- To Simplify the task, assume that + and * always take two arguments and that
-- expressions are fully parenthesised,
--
-- In this implementation, we just change the grammer (and parser thereof) of
-- our expressions as the implementation of `deriv` uses the abstract syntax
-- generated by the parser. Since expressions are parenthesised, we don't need
-- to worry about operator precedence.

parseExpr :: MonadFail m => String -> m Expr
parseExpr s = case runParser p () "" s of
    Left err -> fail $ show err
    Right e  -> return e
  where
    p = do spaces
           e <- expression
           eof
           return e

expression :: Parser Expr
expression  = constant <|> variable <|> antiexpr <|> parens application
  where
    application = do a <- expression
                     f <- add <|> sub <|> multiply <|> divide <|> power
                     f a <$> expression

-- b. The problem becomes substantially harder if we allow standard algebraic
-- notation, such as (x + 3 * (x + y + 2)), which drops unnecessary parenthesis
-- and assumes that multiplication is done before addition. Can you design
-- appropriate predicates, selectors and constructors for this notation such
-- that out derivative program still works?
--
-- Complete via grammar implementation.
